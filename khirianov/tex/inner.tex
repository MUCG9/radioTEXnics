% Схема на 15:17 

\section{Лекция 1. Синтаксис Python}

\subsection{Hello, World!}
Простейшая программа на Python -- это пустая программа: если мы создадим пустой файл, то это будет корректной программой на Python.

Более сложная программа -- это программа, содержащая команду \texttt{print}:
\begin{lstlisting}
print
\end{lstlisting}

Это программа тоже ничего не делает, она лишь упоминает функцию \texttt{print}, которая предназначена для вывода информации на экран, однако это тоже корректная программа на Python.

Следующий шаг -- это программа, которая вызывает функцию \texttt{print}:
\begin{lstlisting}
print()
\end{lstlisting}

Здесь мы вызываем функцию \texttt{print} без аргументов, и она просто выводит пустую строку. Это уже более осмысленная программа, которая выполняет действие.

Если мы хотим вывести что-то конкретное, например, строку "Hello, World!", то мы можем написать:
\begin{lstlisting}
print("Hello, World!")
\end{lstlisting}  

\subsection{Концепция присваивания}
Однако хотелось бы использовать память компьютера для хранения данных, а не только для выполнения команд. Для этого в Python есть переменные. Переменная -- это именованная область памяти, которая может хранить данные. Например, мы можем создать переменную \texttt{x} и присвоить ей строку "Hello, World!":
\begin{lstlisting}
x = "Hello, World!"
print(x)
\end{lstlisting}

В данном примере \texttt{x} -- это имя, которое ссылается на строку "Hello, World!" в памяти. Это объект типа \texttt{str} (строка). Чтобы узнать тип объекта, мы можем использовать функцию \texttt{type}:
\begin{lstlisting}
print(type(x))
\end{lstlisting}  

Зачем нужно давать имена объектам? Это позволяет нам обращаться к данным, которые хранятся в памяти, используя эти имена. То есть мы ссылаемся на объекты через их имена.

Есть тонкость: справа может быть не только объект, но и выражение. Например: 
\begin{lstlisting}
x = 1 + 2 + 3 * 2
print(x)
\end{lstlisting}

В этом случае действия интерпретатора следующие: он сначала вычисляет выражение \texttt{1 + 2 + 3 * 2} -- для этого ему понадобятся временные неименованные объекты, которые будут удалены после вычислений благодаря сборщику мусора (очистке памяти), удаляющий объекты, на которые нет ссылок. После чего результат вычисления (число 9) будет сохранен в памяти, и имя \texttt{x} будет ссылаться на этот объект.

Что будет с объектом после двух и боллее ссылок? Он будет удален, когда на него не будет ссылок. Например:
\begin{lstlisting}
x = "Hello, World!"
print(type(x))
x = 1 + 2 + 3 * 2
\end{lstlisting}

В этом примере строка "Hello, World!" будет удалена из памяти после того, как мы присвоим \texttt{x} новое значение в результате операции связывания. 

\subsection{Обмен двух переменных значениями}

Рассмотрим простейший алгоритм обмена значениями двух переменных \texttt{a} и \texttt{b}:
\begin{lstlisting}
a = 2
b = 5
tmp = a
a = b
b = tmp
\end{lstlisting}

После выполнения этого кода переменная tmp останется висеть в памяти далее по коду, так как на нее есть ссылка. 

Однако в Python есть более простой способ обмена значениями двух переменных через две переменных:
\begin{lstlisting}
a = 2
b = 5
tmp1 = a
tmp2 = b
a = tmp1
b = tmp2
\end{lstlisting}

\subsection{Множественное присваивание}

\begin{lstlisting}
x, y, z = 1, 2, 3
\end{lstlisting}

В этом случае мы пользуемся понятием кортежа. Кортеж -- это упорядоченный набор объектов, который может содержать объекты разных типов.

Тогда обмен значениями двух переменных можно записать так:
\begin{lstlisting}
a = 2
b = 5    
a, b = b, a 
\end{lstlisting}

При этом время на копирование объектов не тратится, так как мы просто создаем ссылки на эти объекты.

\subsection{Арифметические операции}

\begin{enumerate}
    \item Возведение в степень: $x^y \equiv x ** ~ y$ ($\sqrt{3} = 3 ~ ** ~ 0.5, ~ a^{b^c} = a ** ~ b ~ ** ~ c$)
    \item Унарный минус: $-x \equiv -x$
    \item Умножение: $x \cdot y \equiv x * y$
    \item  Деление: $x:y \equiv x / y$
    \item Целочисленное деление: $x \div y \equiv x ~ // ~ y$
    \item Остаток от деления: $x \mod y \equiv x ~ \% ~ y$
    \item Сложение и вычитание: $x + y \equiv x + y, ~ x - y \equiv x - y$
\end{enumerate}

\subsection{Цикл while}

\begin{verbatim}
while условие:
    оператор 1
    if условие 2:
        break
    оператор 2
else:
    после всех итераций цикла
\end{verbatim}




